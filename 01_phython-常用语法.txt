
0.    python中，定义全局变量

      global_last = 0

      def outer():
          # 外层嵌套变量
          nonlocal_last = 0

          def inner():
              global global_last       # 声明改全局变量
              nonlocal nonlocal_last  # 声明改外层嵌套变量
              global_last += 1
              nonlocal_last += 1
              print(global_last, nonlocal_last)  # 输出：1 1

          inner()

      outer()


0.  python中，定义预编译选项

      DEFINES = \
      {
          "TXMODE": True,
          "DEBUG": False,
      }

      # DEFINES = {
      #     "TXMODE": False,
      #     "DEBUG": True,
      # }


      def defined(macro_name):
          is_defined = macro_name in DEFINES
          is_enabled = DEFINES[macro_name]
          return is_defined and is_enabled


      if defined("TXMODE"):
          print("tx")

      elif defined("DEBUG"):
          print("debug")
      else:
          print("默认模式执行")


1。 为什么下面语句打印结果后面有个逗号 

     print("shape-timestamp=", np.shape(timestamp) )  
 
     打印结果： shape-timestamp= (17704,)

    解释： 
    1）.  np.shape() 对一维数组返回 (n,)，是为了和多维数组的 shape 格式（如(n,m)）保持统一；

    2）. Python 里的元组语法规则：

           。零维（单个值，非元组）：17704（无括号，就是普通数字）；
           。 一维元组（只有 1 个元素）：必须加逗号 → (17704,)（少了逗号，(17704) 会被识别成普通数字）；
            。二维元组（2 个元素）：(17704, 2)（逗号分隔多个元素，无需额外逗号）


2. bbb = mag[:, 0, :] [500]  # 相当于写法mag[0:500,0,:]  


3. len(mag[:,  :])      //最外层维度的元素的个数，等价 mag.shape[0] 

    mag.shape=(5, 6)，
    len(mag[:,:])=5


4.  aaa= mag[:, 0, :]    本质是： 
对三维数组 mag 做切片，得到二维数组


5. 对列表的一段元素直接赋值

      mask = [1, 2, 3, 4, 5, 6]
      start = 1
      end = 4

      # 错误写法：mask[start:end] = 2 （报错）    //注意点

      # 正确写法：生成长度为 (end-start) 的列表 [2,2,2]
      mask[start:end] = [2] * (end - start)                        //先生成一个列表，再列表给列表赋值

      print(mask)  # 输出：[1, 2, 2, 2, 5, 6]

6.   下面代码把 print 的输出流强制改成了日志输出

      logging.getLogger('emc_analysis')
      logging.basicConfig(level=logging.INFO)
      logger = logging.getLogger()

      txt_file_name = ".\\logfile.txt"
      if os.path.isfile(txt_file_name):
          open(txt_file_name, 'w').close()
      file_handler = logging.FileHandler(txt_file_name)
      file_handler.setLevel(logging.INFO)

      logger.addHandler(file_handler)

      class LoggerWriter:
          def __init__(self, logger, level):
              self.logger = logger
              self.level = level

          def write(self, message):
              if message and not message.isspace():
                  self.logger.log(self.level, message.strip())

          def flush(self):
              pass  # This method is needed for compatibility with `sys.stdout`

     sys.stdout = LoggerWriter(logger, logging.INFO) 

