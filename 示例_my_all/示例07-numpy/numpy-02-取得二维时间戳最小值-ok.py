import numpy as np


# 关键说明：如有一个设备，step2由二维数组降维成一维数组，省略了行索引。所以要理解np.where，最好有两个以上的设备
#         上面的理解并不准确，实际上np.where取得的值是一维还是二维，是由np.array定义成一维度还是二维决定的

# ---------------------------- 1个设备 -------1维-----------------------

# 原始时间戳数组（已转np.int64）
t0_all = np.array([1620000000000, 1620000001000, 1620000000000, 1620000002000], dtype=np.int64)
t0 = np.min(t0_all)  # 最小值：1620000000000

# 核心代码拆解
step1 = t0_all == t0  # 布尔数组：[True, False, True, False]
print("\nstep1布尔数组（True表示等于t0）：")
print(step1)

step2 = np.where(step1)  # 返回元组：(array([0, 2]),) → 0和2是True的位置 //元组内每个元素是一维数组(元组本身可看作一个数组)
                         # 重点：1个设备元组只有 一个元素，2个设备就有2个元素，三个设备就有3个元素。每个元素是一个数组
print("\nstep2 np.where返回的元组 =", step2)

t0_idx = step2[0]  # 取元组第一个元素：array([0, 2])
# print(t0_idx)  # 输出：[0 2] → 所有等于最小值的元素的索引    # 这里打印的是一维数组
print("t0_idx（列索引） =", t0_idx)  # 输出：[0 2]  //本例只有一个设备，step2由二维数组降维成一维数组，省略了行索引




# ---------------------------- 1个设备 -----2维ok-------------------------

import numpy as np

# 1. 构造二维时间戳数组（2行3列，模拟2个设备、3个时间点的时间戳）
t0_all = np.array([
    [1620000001000, 1620000000000, 1620000003000],  # 设备1的3个时间戳
], dtype=np.int64)

# 2. 先找数组中的最小值t0（最早的时间戳）
t0 = np.min(t0_all)
# print("最小值t0 =", t0)  # 输出：最小值t0 = 1620000000000

# 3. 核心步骤：找所有等于t0的元素的行、列索引
step1 = t0_all == t0  # 布尔数组：标记哪些位置等于t0
print("\nstep1布尔数组（True表示等于t0）：")
print(step1)
# 输出：
# [[False  True False]
#  [False False  True]]

step2 = np.where(step1)  # 返回索引元组：(行索引数组, 列索引数组)
print("\nstep2 np.where返回的元组 =", step2)
# 输出：np.where返回的元组step2 = (array([0, 1]), array([1, 2]))

# 4. 提取行索引和列索引（对应你的t0_idx0、t0_idx1）
t0_idx0 = step2[0]  # 行索引数组：[0, 1] → 第0行、第1行有最小值
t0_idx1 = step2[1]  # 列索引数组：[1, 2] → 第1列、第2列有最小值

print("\nt0_idx0（行索引） =", t0_idx0)  # 输出：[0 1]
print("t0_idx1（列索引） =", t0_idx1)  # 输出：[1 2]



# ---------------------------- 2个设备 -----------2维ok-------------------

import numpy as np

# 1. 构造二维时间戳数组（2行3列，模拟2个设备、3个时间点的时间戳）
t0_all = np.array([
    [1620000001000, 1620000000000, 1620000003000],  # 设备1的3个时间戳
    [1620000002000, 1620000004000, 1620000000000]   # 设备2的3个时间戳
], dtype=np.int64)

# 2. 先找数组中的最小值t0（最早的时间戳）
t0 = np.min(t0_all)
# print("最小值t0 =", t0)  # 输出：最小值t0 = 1620000000000

# 3. 核心步骤：找所有等于t0的元素的行、列索引
step1 = t0_all == t0  # 布尔数组：标记哪些位置等于t0
print("\nstep1布尔数组（True表示等于t0）：")
print(step1)
# 输出：
# [[False  True False]
#  [False False  True]]

step2 = np.where(step1)  # 返回索引元组：(行索引数组, 列索引数组)
print("\nstep2 np.where返回的元组 =", step2)
# 输出：np.where返回的元组step2 = (array([0, 1]), array([1, 2]))

# 4. 提取行索引和列索引（对应你的t0_idx0、t0_idx1）
t0_idx0 = step2[0]  # 行索引数组：[0, 1] → 第0行、第1行有最小值
t0_idx1 = step2[1]  # 列索引数组：[1, 2] → 第1列、第2列有最小值

print("\nt0_idx0（行索引） =", t0_idx0)  # 输出：[0 1]
print("t0_idx1（列索引） =", t0_idx1)  # 输出：[1 2]


# ---------------------------- 2个设备 -----设备二有2个最小值------2维ok -------------------

import numpy as np

# 1. 构造二维时间戳数组（2行3列，模拟2个设备、3个时间点的时间戳）
t0_all = np.array([
    [1620000001000, 1620000000000, 1620000003000],  # 设备1的3个时间戳
    [1620000000000, 1620000004000, 1620000000000]   # 设备2的3个时间戳
], dtype=np.int64)

# 2. 先找数组中的最小值t0（最早的时间戳）
t0 = np.min(t0_all)
print("最小值t0 =", t0)  # 输出：最小值t0 = 1620000000000

# 3. 核心步骤：找所有等于t0的元素的行、列索引
step1 = t0_all == t0  # 布尔数组：标记哪些位置等于t0
print("\n布尔数组（True表示等于t0）：")
print(step1)
# 输出：
# [[False  True False]
#  [False False  True]]

step2 = np.where(step1)  # 返回索引元组：(行索引数组, 列索引数组)
print("\nnp.where返回的元组step2 =", step2)
# 输出：np.where返回的元组step2 = (array([0, 1]), array([1, 2]))

# 4. 提取行索引和列索引（对应你的t0_idx0、t0_idx1）
t0_idx0 = step2[0]  # 行索引数组：[0, 1] → 第0行、第1行有最小值
t0_idx1 = step2[1]  # 列索引数组：[1, 2] → 第1列、第2列有最小值

print("\nt0_idx0（行索引） =", t0_idx0)  # 输出：[0 1]
print("t0_idx1（列索引） =", t0_idx1)  # 输出：[1 2]


# ---------------------------- 3个设备 -----设备二有2个最小值------ok-------------------

import numpy as np

# 1. 构造二维时间戳数组（2行3列，模拟2个设备、3个时间点的时间戳）
t0_all = np.array([
    [1620000001000, 1620000000000, 1620000003000],  # 设备1的3个时间戳
    [1620000000000, 1620000004000, 1620000000000],   # 设备2的3个时间戳
    [1620000002000, 1620000004000, 1620000000000]  # 设备2的3个时间戳
], dtype=np.int64)

# 2. 先找数组中的最小值t0（最早的时间戳）
t0 = np.min(t0_all)
print("最小值t0 =", t0)  # 输出：最小值t0 = 1620000000000

# 3. 核心步骤：找所有等于t0的元素的行、列索引
step1 = t0_all == t0  # 布尔数组：标记哪些位置等于t0
print("\n布尔数组（True表示等于t0）：")
print(step1)
# 输出：
# [[False  True False]
#  [False False  True]]

step2 = np.where(step1)  # 返回索引元组：(行索引数组, 列索引数组)
print("\nnp.where返回的元组step2 =", step2)
# 输出：np.where返回的元组step2 = (array([0, 1]), array([1, 2]))

# 4. 提取行索引和列索引（对应你的t0_idx0、t0_idx1）
t0_idx0 = step2[0]  # 行索引数组：[0, 1] → 第0行、第1行有最小值
t0_idx1 = step2[1]  # 列索引数组：[1, 2] → 第1列、第2列有最小值

print("\nt0_idx0（行索引） =", t0_idx0)  # 输出：[0 1]
print("t0_idx1（列索引） =", t0_idx1)  # 输出：[1 2]



