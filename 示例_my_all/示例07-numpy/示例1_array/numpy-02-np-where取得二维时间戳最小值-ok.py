
#np.where取得的值是一维还是二维，是由np.array定义成一维度还是二维决定的
#如果是一维，只有t0_idx1= np.where(step1)[0]，为列索引 （可把不存在的行索引看作都是0行）



import numpy as np


# 答疑：如只有一个设备，step2由二维数组降维成一维数组，省略了行索引。所以要理解np.where，最好有两个以上的设备
#      上面的理解并不准确，实际上np.where取得的值永远是二维，如np.array定义成一维则只有一个列表元素，如np.array定义成二维则有两个列表元素

# ----------------test1------------ 1个设备 -------1维-----------------------

# 原始时间戳数组（已转np.int64）
t0_all = np.array([1620000000000, 1620000001000, 1620000000000, 1620000002000], dtype=np.int64)
t0 = np.min(t0_all)  # 最小值：1620000000000

print(t0_all)

# 核心代码拆解
step1 = t0_all == t0  # 布尔数组：[True, False, True, False]
print("\nstep1布尔数组（True表示等于t0）：")
print(step1)

step2 = np.where(step1)  # 返回元组：(array([0, 2]),) → 0和2是True的位置 //元组内每个元素是一维数组(元组本身可看作一个数组)
                         # 重点：1个设备元组只有 一个元素，2个设备就有2个元素，三个设备就有3个元素。每个元素是一个数组
print("\nstep2 np.where返回的元组 =", step2)

t0_idx1 = step2[0]  # 取元组第一个元素：array([0, 2])

print("t0_idx1（列索引） =", t0_idx1)  # 输出：[0 2]  一维数组只有列索引，省略了行索引（可把不存在的行索引看作都是0行）


# -----------------test2----------- 1个设备 -----2维ok-------------------------

import numpy as np

# 1. 构造二维时间戳数组（2行3列，模拟2个设备、3个时间点的时间戳）
t0_all = np.array([
    [1620000000000, 1620000001000, 1620000000000, 1620000002000],  # 设备1的3个时间戳
], dtype=np.int64)

print(t0_all)

# 2. 先找数组中的最小值t0（最早的时间戳）
t0 = np.min(t0_all)
# print("最小值t0 =", t0)  # 输出：最小值t0 = 1620000000000

# 3. 核心步骤：找所有等于t0的元素的行、列索引
step1 = t0_all == t0  # 布尔数组：标记哪些位置等于t0
print("\nstep1布尔数组（True表示等于t0）：")
print(step1)
# 输出：
# [[False  True False]]

step2 = np.where(step1)  # 返回索引元组：(行索引数组, 列索引数组)
print("\nstep2 np.where返回的元组 =", step2)
# 输出：np.where返回的元组step2 = (array([0, 1]), array([1, 2]))

# 4. 提取行索引和列索引（对应你的t0_idx0、t0_idx1）
t0_idx0 = step2[0]  # 行索引数组：[0, 1] → 第0行、第1行有最小值
t0_idx1 = step2[1]  # 列索引数组：[1, 2] → 第1列、第2列有最小值

print("\nt0_idx0（行索引） =", t0_idx0)  # 输出：[0 1]
print("t0_idx1（列索引） =", t0_idx1)  # 输出：[1 2]


# # -----------------test3----------- 2个设备 -----------2维ok-------------------
#
# import numpy as np
#
# # 1. 构造二维时间戳数组（2行3列，模拟2个设备、3个时间点的时间戳）
# t0_all = np.array([
#     [1620000001000, 1620000000000, 1620000003000],  # 设备1的3个时间戳
#     [1620000002000, 1620000004000, 1620000000000]   # 设备2的3个时间戳
# ], dtype=np.int64)
#
# # 2. 先找数组中的最小值t0（最早的时间戳）
# t0 = np.min(t0_all)
# # print("最小值t0 =", t0)  # 输出：最小值t0 = 1620000000000
#
# # 3. 核心步骤：找所有等于t0的元素的行、列索引
# step1 = t0_all == t0  # 布尔数组：标记哪些位置等于t0
# print("\nstep1布尔数组（True表示等于t0）：")
# print(step1)
# # 输出：
# # [[False  True False]
# #  [False False  True]]
#
# step2 = np.where(step1)  # 返回索引元组：(行索引数组, 列索引数组)
# print("\nstep2 np.where返回的元组 =", step2)
# # 输出：np.where返回的元组step2 = (array([0, 1]), array([1, 2]))
#
# # 4. 提取行索引和列索引（对应你的t0_idx0、t0_idx1）
# t0_idx0 = step2[0]  # 行索引数组：[0, 1] → 第0行、第1行有最小值
# t0_idx1 = step2[1]  # 列索引数组：[1, 2] → 第1列、第2列有最小值
#
# print("\nt0_idx0（行索引） =", t0_idx0)  # 输出：[0 1]
# print("t0_idx1（列索引） =", t0_idx1)  # 输出：[1 2]
#
#
# # ---------------test4------------- 2个设备 -----设备二有2个最小值------2维ok -------------------
#
# import numpy as np
#
# # 1. 构造二维时间戳数组（2行3列，模拟2个设备、3个时间点的时间戳）
# t0_all = np.array([
#     [1620000001000, 1620000000000, 1620000003000],  # 设备1的3个时间戳
#     [1620000000000, 1620000004000, 1620000000000]   # 设备2的3个时间戳
# ], dtype=np.int64)
#
# # 2. 先找数组中的最小值t0（最早的时间戳）
# t0 = np.min(t0_all)
# print("最小值t0 =", t0)  # 输出：最小值t0 = 1620000000000
#
# # 3. 核心步骤：找所有等于t0的元素的行、列索引
# step1 = t0_all == t0  # 布尔数组：标记哪些位置等于t0
# print("\n布尔数组（True表示等于t0）：")
# print(step1)
# # 输出：
# # [[False  True False]
# #  [False False  True]]
#
# step2 = np.where(step1)  # 返回索引元组：(行索引数组, 列索引数组)
# print("\nnp.where返回的元组step2 =", step2)
# # 输出：np.where返回的元组step2 = (array([0, 1]), array([1, 2]))
#
# # 4. 提取行索引和列索引（对应你的t0_idx0、t0_idx1）
# t0_idx0 = step2[0]  # 行索引数组：[0, 1] → 第0行、第1行有最小值
# t0_idx1 = step2[1]  # 列索引数组：[1, 2] → 第1列、第2列有最小值
#
# print("\nt0_idx0（行索引） =", t0_idx0)  # 输出：[0 1]
# print("t0_idx1（列索引） =", t0_idx1)  # 输出：[1 2]
#
#
# # ----------------test5------------ 3个设备 -----设备二有2个最小值------ok-------------------
#
# import numpy as np
#
# # 1. 构造二维时间戳数组（2行3列，模拟2个设备、3个时间点的时间戳）
# t0_all = np.array([
#     [1620000001000, 1620000000000, 1620000003000],  # 设备1的3个时间戳
#     [1620000000000, 1620000004000, 1620000000000],   # 设备2的3个时间戳
#     [1620000002000, 1620000004000, 1620000000000]  # 设备2的3个时间戳
# ], dtype=np.int64)
#
# # 2. 先找数组中的最小值t0（最早的时间戳）
# t0 = np.min(t0_all)
# print("最小值t0 =", t0)  # 输出：最小值t0 = 1620000000000
#
# # 3. 核心步骤：找所有等于t0的元素的行、列索引
# step1 = t0_all == t0  # 布尔数组：标记哪些位置等于t0
# print("\n布尔数组（True表示等于t0）：")
# print(step1)
# # 输出：
# # [[False  True False]
# #  [False False  True]]
#
# step2 = np.where(step1)  # 返回索引元组：(行索引数组, 列索引数组)
# print("\nnp.where返回的元组step2 =", step2)
# # 输出：np.where返回的元组step2 = (array([0, 1]), array([1, 2]))
#
# # 4. 提取行索引和列索引（对应你的t0_idx0、t0_idx1）
# t0_idx0 = step2[0]  # 行索引数组：[0, 1] → 第0行、第1行有最小值
# t0_idx1 = step2[1]  # 列索引数组：[1, 2] → 第1列、第2列有最小值
#
# print("\nt0_idx0（行索引） =", t0_idx0)  # 输出：[0 1]
# print("t0_idx1（列索引） =", t0_idx1)  # 输出：[1 2]
#
#
#
